#include <fcntl.h>
#include <stdio.h>
#include <signal.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <termios.h>
#include <sys/stat.h>
#include <sys/select.h>

/* partial implementation of a remote server/transmitter for the
 * Newsroom Wire Service */

/* hardcoded to /dev/ttyUSB[01] and 300 baud, modify as you see fit */
/* pass filenames on the command line. expects ph.*, pn.* prefixes */

/* (C)2023 Cameron Kaiser. All rights reserved. BSD license. */

/* known gaps:
 *
 * nak and can not handled
 * only supports all-text panels, photo panels and photos
 * filenames should be all lower case (upper case not handled)
 * can't handle filenames greater than 11 characters (packet too small)
   (but Newsroom limited to eight-character filenames anyway)
 * photos limited to genpho 231x148 resolution due to bit manipulation
 * packet computation invalid for photo panels with greater than 1 packet
 * only photo panels generated by gencap supported
 * last bit of photos isn't same as spec, but doesn't matter
 */

/* set to see packet output instead of transmitting it */
//#define DRY 1

int porta;
struct termios ttya, ttya_saved;
struct sigaction hothotsig;
unsigned char bytes[134];

void
cleanup()
{
#if DRY
	return;
#else
	(void)tcsetattr(porta, TCSAFLUSH, &ttya_saved);
	(void)close(porta);
#endif
}

void
hotsigaction(int hotsig)
{
	fprintf(stdout, "\n\nexiting on signal\n");
	cleanup();
	exit(0);
}

/* from http://textfiles.com/programming/ymodem.txt */
int
calcrc(unsigned char *ptr, int count)
{
	int i, crc = 0;

	while (--count >= 0) {
		crc = crc ^ (int)*ptr++ << 8;
		for (i=0; i<8; ++i)
			if (crc & 0x8000)
				crc = crc << 1 ^ 0x1021;
			else
				crc = crc << 1;
	}
	return (crc & 0xffff);
}

#ifdef CHAR_BIT
#if CHAR_BIT != 8
#error what platform hell is this
#endif
#endif

void
bitflip()
{
	int i;
	unsigned char b;

	for (i=4; i<132; i++) {
		b = bytes[i];
		b = (b & 0xf0) >> 4 | (b & 0x0f) << 4;
		b = (b & 0xcc) >> 2 | (b & 0x33) << 2;
		b = (b & 0xaa) >> 1 | (b & 0x55) << 1;
		bytes[i] = b;
	}
}

void
wack()
{
#if DRY
	return;
#else
	unsigned char c = 0;
	while (c != 6) {
		read(porta, &c, 1); /* blocks */
		if (c != 6) {
			perror("didn't receive client ack");
		}
	}
#endif
}

void
send()
{
	int i;

	bytes[0] = 0xaa;
	bytes[1] = 0x55;
	if (bytes[2] != 0 || bytes[3] != 0) {
		fprintf(stderr, "assertion: bytes not cleared\n");
		exit(255);
	}

	/* compute CRC-16 */
	i = calcrc(&(bytes[4]), 128);
	bytes[132] = (i >> 8);
	bytes[133] = i & 255;

#if DRY
	fprintf(stdout, "-----\n");
	for(i=0; i<134; i++)
		fprintf(stdout, " %02x ", bytes[i]);
	fprintf(stdout, "\n\n");
#else
	/* blocking i/o */
	wack();
	write(porta, &bytes, 134);
	wack();
	fprintf(stderr, ".");
#endif

	memset(&bytes, 0, sizeof(bytes));
}

int
main(int argc, char **argv)
{
	fd_set master, rfd, wfd;
	struct timeval tv;
	struct stat fi;
	unsigned char c;
	unsigned char *files[255];
	off_t flen[255];
	unsigned char ft[255];
	unsigned char fflen[8];
	int i, ii, j, k, l, f;

	if (argc < 2) {
		fprintf(stderr, "usage: %s files\n", argv[0]);
		return 1;
	}
	for(j=1; j<argc; j++) {
		f = open(argv[j], O_RDONLY);
		if (f < 1) {
			perror("open");
			return 1;
		}
		if (fstat(f, &fi)) {
			perror("fstat");
			return 1;
		}
		files[j-1] = (unsigned char *)malloc(fi.st_size);
		read(f, files[j-1], fi.st_size);
		close(f);
		flen[j-1] = fi.st_size;
		ft[j-1] = 2; /* default to panel */
		fprintf(stderr, "read %s (%d bytes)\n", argv[j], fi.st_size);

		/* rework filename if needed */
		if (strstr(argv[j], "pn.") == argv[j]) {
			argv[j] += 3;
			fprintf(stderr, "... panel rewritten to %s\n", argv[j]);
		}
		if (strstr(argv[j], "ph.") == argv[j]) {
			unsigned char *bub, *buc; 
			unsigned char *buf = files[j-1];
			int ib, ob, bc;

			/* photos need preprocessing */

			argv[j] += 3;
			fprintf(stderr, "... photo rewritten to %s\n", argv[j]);
			ft[j-1] = 3;

			/* XXX: only supports 231x148 images, no metadata */
			if ((buf[5]-buf[4]) != 147 || (buf[7]-buf[6]) != 230) {
				fprintf(stderr, "must be 231x148 photo\n");
				return 1;
			}
			if (buf[8] != 0 || buf[9] != 255) {
				fprintf(stderr, "unexpected bitmap offset\n");
				return 1;
			}

			/* pack bits from msb-first image, keep msb first */
			bc = 0; /* bit count */
			ib = 0; /* input bit of byte */
			ob = 128; /* output bit of byte */
			buc = (unsigned char *)malloc(fi.st_size);
			memset(buc, 0, sizeof(buc));
			/* data starts at offset 10, so copy+skip header */
			memcpy(buc, buf, 10);
			bub = buc + 10;
			buf += 10;
			for(k=0;k<=4292*8;k++) {
				/* read in next bit */
				c = (*buf & 128);
				*buf <<= 1;
				if (++ib == 8) {
					buf++;
					ib = 0;
				}
				if (++bc != 232) { /* skip every 232nd bit */
					/* write out bit, preserve endianness */
					if (c) *bub |= ob;
					ob >>= 1;
					if (!ob) {
						bub++;
						ob = 128;
					}
				} else { bc = 0; }
			}
			files[j-1] = buc;
		}
		if (strlen(argv[j]) > 11) {
			fprintf(stderr, "filename more than 11 characters\n");
			return 1;
		}
	}

#ifndef DRY
	porta = open("/dev/ttyUSB0", O_RDWR | O_NOCTTY);
	if (tcgetattr(porta, &ttya_saved)) {
		perror("tcgetattr (A)");
		close(porta);
		return 1;
	}

	atexit(cleanup);
	(void)memset(&hothotsig, 0, sizeof(hothotsig));
	hothotsig.sa_handler = hotsigaction;
	sigaction(SIGINT, &hothotsig, NULL);
	sigaction(SIGTERM, &hothotsig, NULL);
	sigaction(SIGHUP, &hothotsig, NULL);

	memset(&ttya, 0, sizeof(ttya));
	ttya.c_cflag = (CS8 | CREAD | CLOCAL); /* 300bps 8N1 no flow control */
	ttya.c_cc[VTIME] = 5;
	ttya.c_cc[VMIN] = 1;
	cfsetospeed(&ttya, B300);
	cfsetispeed(&ttya, B300);
	tcsetattr(porta, TCSANOW, &ttya);

	FD_ZERO(&master);
	FD_SET(porta, &master);
	tv.tv_sec = 0;
	tv.tv_usec = 0;

#endif

	setvbuf(stderr, NULL, _IONBF, 0); /* select(STDERR); $|++; */
	memset(&bytes, 0, sizeof(bytes));
	for(j=0; j<(argc-1); j++) {
		int pax;

		/* number of packets: file bytes 2 and 3, round up to nearest
 			multiple of 128, add one for initial packet */
		pax = 1 + files[j][3] + files[j][3];
		pax += (files[j][2] & 127) ? 1 : 0;
		pax += (files[j][2] & 128) ? 1 : 0;
		/* add interstitial packet for photos */
		pax += (ft[j] == 3) ? 1 : 0;
		fprintf(stderr, "file %d: %s (%d blocks) ", j+1, argv[j+1],
			pax);

		/* packet 1: filename and length */
		bytes[4] = ft[j];

		/* number of bytes in packets at byte 130 */
		bytes[130] = ((pax & 1) << 7);
		bytes[131] = pax >> 1;

		/* filename starts at byte 5 */
		for(i=0; i<strlen(argv[j+1]); i++) {
			bytes[5+i] = argv[j+1][i] + 96 +
				((argv[j+1][i] < 64) ? 32 : 0);
		}

		/* 7-byte ASCII number of bytes in packets at byte 17 */
		sprintf(fflen, "%07d", pax << 7);
		for(i=0; i<7; i++)
			bytes[17+i] = fflen[i];
		
		/* files remaining, including this one */
		bytes[128] = 0xff; /* don't care byte? */
		bytes[129] = (argc-1)-j;

		send();

		/* packet 2: metadata, I guess */
		bytes[4] = files[j][2]; /* length */
		bytes[5] = files[j][3];
		bytes[6] = files[j][4]; /* font a or photo top */
		bytes[8] = files[j][5]; /* font b or photo bottom*/
		bytes[10] = files[j][6]; /* don't-care? or photo left */
		bytes[12] = files[j][7]; /* don't care? or photo right */

		/* photo information is part of metadata for photo panels */
		if (ft[j] == 2 && files[j][8] == 1) {
			/* tag as photo panel, place coordinates */
			bytes[14] = files[j][8];
			bytes[16] = files[j][9];
			bytes[18] = files[j][10];
			bytes[20] = files[j][11];
			bytes[22] = files[j][12]-1; /* ?! */
			bytes[24] = files[j][13]-1;
			/* filename */
			for(i=0;i<8;i++)
				if (files[j][14+i])
					bytes[26+i] = files[j][14+i] | 128;

			/* don't retransmit */
			files[j] += 13;
			flen[j] -= 13;
		}
		
		send();

		/* packet 3: photos only: padding */
		if (ft[j] == 3) {
			bytes[4] = 255;
			send();
		}

		/* send remainder of file as blocks */
		files[j] += 9;
		flen[j] -= 9;
		if (ft[j] == 3) { files[j]++; flen[j]--; } /* skip ff */
		while(flen[j] > 127) {
			memcpy(&(bytes[4]), files[j], 128);
			if (ft[j] == 3) bitflip(); /* MSB -> LSB */
			send();
			flen[j] -= 128;
			files[j] += 128;
		}
		if (flen[j]) {
			memcpy(&(bytes[4]), files[j], flen[j]);
			if (ft[j] == 3) bitflip(); /* MSB -> LSB */
			send();
		}
		fprintf(stderr, "\nfile %d complete\n", j+1);
	}
	fprintf(stderr, "\nall glory to the hypnotoad\n");
	return 0;
}
